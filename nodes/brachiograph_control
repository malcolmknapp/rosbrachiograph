#!/usr/bin/env python3

# creates a ros node that controls two servo motors
# on a arduino running ros serial
# ---------------
# by malcolm knapp
# github.com/malcolmknap
# malcolm@mfhkconsulting.com
# 041421
# adapted from head_motor_control.py by oran collins

import rospy
import math
import shlex
import argparse


from std_msgs.msg import String
from rosbrachiograph.msg import ServoPosition
from rosbrachiograph.msg import PenPosition
from geometry_msgs.msg import Twist
from rosbrachiograph.brachiograph import BrachioGraph
from rosbrachiograph.brachiograph import Pen

global shoulder_servo
global elbow_servo
global pen_servo
global sub
global shoulder_servo_position
global elbow_servo_position
global pen_servo_position
#global jog_size


#current positins
pen_current_pos = 245
elbow_current_pw = 345
shoulder_current_pw = 310


#calibration
servo_1_angle_pws1 = [
    [90 ,122],
    [72 ,152],
    [54 ,196],
    [36 ,236],
    [18 ,272],
    [0 ,310],
    [-18 ,340],
    [-36 ,380],
    [-54 ,420],
    [-72 ,460],
    [-90 ,506],
]
servo_2_angle_pws2 = [
    [0, 181],
    [18, 221],
    [36, 261],
    [54, 301],
    [72, 345],
    [90, 387],
    [108, 421 ],
    [126, 463],
    [144, 507],
]

# standard delay between moving the joints
DELAY = 1.0
# setting up interger variables
#     the arduino only accepts integers
jog_msg = ServoPosition ()
pen_msg = PenPosition ()


shoulder_min = 100  # in degrees from x to y angles are accepted positions
sholder_max = 400
elbow_min = 100
elbow_max = 500
pen_max = 110
pen_min = 500
state = "idle"
event = "none"
shoulder_angle = -90
elbow_angle = 90

# helper function
# keeps the input number between a high and alow
def constrain(input: float, low: float, high: float) -> float:
    """
    input: radian float  an number to be constrained to a range low<-> high
    low: radian float minimum value the input can be
    high: radian float maximum value the input can be
    """
    return max(min(input, high), low)


def move_pen(move="up"):
    global pen_current_pos

    if move == "up":
        pen_msg.pen_pos = pen_current_pos = bg.pen.pw_up
        rospy.loginfo("Move pen up to {}".format (pen_current_pos))
    if move == "down":
        pen_msg.pen_pos = pen_current_pos = bg.pen.pw_down
        rospy.loginfo("Move pen down to {}".format (pen_current_pos))
    jog_pen.publish(pen_msg)
    rospy.sleep(DELAY)

#jog the brachiograph manually
def jog_position(msg: Twist) -> None:
    #rospy.loginfo("current x,y:  {},{}".format (round (bg.current_x,3) ,round (bg.current_y,3)))
    global bg
    jog_size_xy = .5
    jog_size_xy_fine = .1
    jog_size_pw = 10
    jog_size_pw_fine = 2
    jog_size = 0
    new_x = bg.current_x
    new_y = bg.current_y
    shoulder_current_pw = bg.current_shoulder_pw
    elbow_current_pw = bg.current_elbow_pw

    if state == "jog_xy" or state == "jog_xy_fine":
        if state == "jog_xy":
            jog_size = jog_size_xy
        else: 
            jog_size = jog_size_xy_fine
        if msg.angular.z < 0:
            new_x = bg.current_x - jog_size
        if msg.angular.z > 0: 
            new_x = bg.current_x + jog_size
        if msg.linear.x > 0:
            new_y = bg.current_y - jog_size
        if msg.linear.x < 0:
            new_y = bg.current_y + jog_size
        bg.xy(new_x, new_y) 
        rospy.sleep(DELAY)

    
    if state == "jog_pw" or state == "jog_pw_fine":
        if state == "jog_pw":
            jog_size = jog_size_pw
        else: 
            jog_size = jog_size_pw_fine
       
        #rospy.loginfo("state %s", state) 
        #rospy.loginfo("teleop msg:\n %s",msg)

        if msg.angular.z < 0:
            bg.current_shoulder_pw = bg.current_shoulder_pw - jog_size
        if msg.angular.z > 0:
            bg.current_shoulder_pw = bg.current_shoulder_pw + jog_size
        if msg.linear.x > 0:
            bg.current_elbow_pw = bg.current_elbow_pw - jog_size
        if msg.linear.x < 0:
            bg.current_elbow_pw = bg.current_elbow_pw + jog_size
        
        jog_msg.shoulder_pos = bg.current_shoulder_pw
        jog_msg.elbow_pos = bg.current_elbow_pw

        shoulder_angle, elbow_angle = bg.pulse_widths_to_angles(bg.current_shoulder_pw,bg.current_elbow_pw)
        test_pw_1, test_pw_2  = bg.angles_to_pulse_widths(shoulder_angle, elbow_angle)

        rospy.loginfo("pw,s,{},e,{}".format (bg.current_shoulder_pw,bg.current_elbow_pw))
        rospy.loginfo("angle,s,{},e,{}".format (round (shoulder_angle,0),round (elbow_angle,0)))
        jog_servo.publish(jog_msg)
        rospy.sleep(DELAY)

def cmd_parse(msg:String) -> None:
    global state
    global event
    global shoulder_angle
    global elbow_angle
    global point_x
    global point_y

    rospy.loginfo("parsing command")
    parser = argparse.ArgumentParser (description = "ros brachiograph cli")
    parser.add_argument("cmd")

    #jog commands 
    parser.add_argument("--xy", action="store_true")
    parser.add_argument("--xy_fine", action="store_true")
    parser.add_argument("--pw", action="store_true")
    parser.add_argument("--pw_fine", action="store_true")

    #pen command
    parser.add_argument("-u", "--up", action="store_true")
    parser.add_argument("-d", "--down", action="store_true")
    parser.add_argument("--done", action="store_true")
    
    #test command 
    parser.add_argument("-l", "--line", action="store_true")
    parser.add_argument("-b", "--box", action="store_true")
    parser.add_argument("-g", "--grid", action="store_true")
    parser.add_argument("-a", "--angle",nargs=2,  type=int)
    parser.add_argument("-p", "--point",nargs=2,  type=int) 
    parser.add_argument("-t", "--pattern", action="store_true")

    args = parser.parse_args(shlex.split(msg.data))
    rospy.loginfo(msg.data)  

    if args.cmd == "home":
        state = "homing"
        rospy.loginfo("homing brachiograph")

    if args.cmd == "plot":
        state = "plotting"
        rospy.loginfo("plotting file")

    if args.cmd == "pen":
        if args.up:
            event = "up"
            rospy.loginfo("pen up")
        if args.down:
            event = "down"
            rospy.loginfo("pen down")

    if args.cmd == "jog":
        if args.xy:
            state = "jog_xy"
            rospy.loginfo(" Now jogging xy")
        if args.xy_fine:
            state = "jog_xy_fine"
            rospy.loginfo(" Now jogging xy fine")
        if args.pw:
            state = "jog_pw"
            rospy.loginfo(" Now jogging pw")
        if args.pw_fine:
            state = "jog_pw_fine"
            rospy.loginfo(" Now jogging pw fine")
        if args.done:
            state = "idle"
            rospy.loginfo("done jogging")
    if args.cmd == "test":
        if args.line:
            state = "line"
            rospy.loginfo("testing line")
        if args.angle:
            state = "angle"
            shoulder_angle = args.angle[0]
            elbow_angle = args.angle[1]
            rospy.loginfo("test go to angle: shoulder {}, elbow {}".format (shoulder_angle,elbow_angle))
        if args.box:
            state = "box"
            rospy.loginfo("test drawing a box")
        if args.grid:
            state = "grid"
            rospy.loginfo("drawing test grid\n")
        if args.point:
            state = "point"
            point_x = args.point[0]
            point_y = args.point[1]
            rospy.loginfo("test go to point: x {}, y {}".format (point_x,point_y))
        if args.pattern:
            state = "pattern"
            rospy.loginfo("drawing a test pattern")
            
if __name__ == "__main__":
    test_bounds = [-10.4, 10, -3, 5]
    bg = BrachioGraph(
        # the lengths of the arms
        inner_arm=8,
        outer_arm=6.5,
        servo_1_centre=310,        # shoulder motor centre pulse-width
        servo_2_centre=345,        # elbow motor centre pulse-width
        # the drawing area
        bounds=test_bounds,
        # angles in degrees and corresponding pulse-widths for the two arm servos
        servo_1_angle_pws=servo_1_angle_pws1,
        servo_2_angle_pws=servo_2_angle_pws2,
        servo_1_degree_ms=-1.08,      # shoulder servo conversion. milliseconds pulse-width per degree
        servo_2_degree_ms=1,       # elbow servo conversion. Reversed to compensate for mounting. milliseconds pulse-width per degree
        arm_1_centre=90,
        arm_2_centre=94,
        # pulse-widths for pen up/down
        hysteresis_correction_1=0,  # hardware error compensation
        hysteresis_correction_2=0,
        wait=1,
        pw_down=110,
        pw_up=350
        )
    rospy.init_node("brachiograph_control_node")
    bg.ROSinit()

    # setup topics to control into arduino servo angles
    # publishing a integer between pulse width 50 - 400 
    jog_servo = rospy.Publisher("jog_servo", ServoPosition, queue_size=1)
    jog_pen = rospy.Publisher("jog_pen", PenPosition, queue_size=1)
    sub = rospy.Subscriber("/cmd_vel", Twist, jog_position)
    sub = rospy.Subscriber("/cli", String, cmd_parse)

    rate = rospy.Rate(10)
    print("Control is Running")
    while not rospy.is_shutdown():
        if state == "homing" :
            bg.park ()
            state = "idle"
        if state == "plotting":
            bg.plot_file(filename = "/home/ubuntu/catkin_ws/src/rosbrachiograph/images/africa.json")
            state = "idle"
        if event == "up":
            move_pen ("up")
            event = "none"
        if event == "down":
            move_pen ("down") 
            event = "none"
        if state == "angle" :
            bg.set_angles(angle_1=shoulder_angle, angle_2=elbow_angle)
            state = "idle"          
        if state == "line" :
            bg.vertical_lines(bounds = test_bounds, wait = 10, interpolate = 20)
            state = "idle"
        if state == "box":
            bg.box(bounds = test_bounds, wait = 1, interpolate = 10 )
            state = "idle"
        if state == "grid":
            bg.grid_lines(bounds = test_bounds, wait = 1, interpolate = 10 )
            state = "idle"
        if state == "point":
            bg.xy(x=point_x, y=point_y, wait = 1, interpolate = 10 )
            state = "idle"
        if state == "pattern":
            bg.test_pattern(bounds = test_bounds, wait = 1, interpolate = 10)
            state = "idle"

        rate.sleep()