#!/usr/bin/env python3

# creates a ros node that controls two servo motors
# on a arduino running ros serial
# ---------------
# by malcolm knapp
# github.com/malcolmknap
# malcolm@mfhkconsulting.com
# 041421
# adapted from head_motor_control.py by oran collins

import rospy
import math
import shlex
import argparse


from std_msgs.msg import String
from rosbrachiograph.msg import ServoPosition
from rosbrachiograph.msg import PenPosition
from geometry_msgs.msg import Twist
from rosbrachiograph.brachiograph import BrachioGraph
from rosbrachiograph.brachiograph import Pen

global shoulder_servo
global elbow_servo
global pen_servo
global sub
global shoulder_servo_position
global elbow_servo_position
global pen_servo_position
global jog_size



#hard code home position



#current positins
pen_current_pos = 150
elbow_current_pos = 150
shoulder_current_pos = 150

# standard delay between moving the joints
DELAY = 1.0
# setting up interger variables
#     the arduino only accepts integers
jog_msg = ServoPosition ()
pen_msg = PenPosition ()

shoulder_min = 100  # in degrees from x to y angles are accepted positions
sholder_max = 400
elbow_min = 100
elbow_max = 500
pen_max = 150
pen_min = 300
state = "idle"

#calibration
servo_1_angle_pws1 = [
    [-162, 2470],
    [-144, 2250],
    [-126, 2050],
    [-108, 1860],
    [ -90, 1690],
    [ -72, 1530],
    [ -54, 1350],
    [ -36, 1190],
    [ -18, 1010],
    [   0,  840],
    [  18,  640],
]
servo_2_angle_pws2 = [
    [  0,  660],
    [ 18,  840],
    [ 36, 1030],
    [ 54, 1180],
    [ 72, 1340],
    [ 90, 1490],
    [108, 1640],
    [126, 1830],
    [144, 2000],
    [162, 2200],
    [180, 2410],
]

# helper function
# keeps the input number between a high and alow
def constrain(input: float, low: float, high: float) -> float:
    """
    input: radian float  an number to be constrained to a range low<-> high
    low: radian float minimum value the input can be
    high: radian float maximum value the input can be
    """
    return max(min(input, high), low)

def homing():
    shoulder_home_pos = 225
    elbow_home_pos = 300
    pen_home_pos = 300

    global shoulder_current_pos 
    global elbow_current_pos
    global pen_current_pos

    shoulder_current_pos = shoulder_home_pos
    elbow_current_pos = elbow_home_pos
    pen_current_pos = pen_home_pos

    jog_msg.shoulder_pos = shoulder_home_pos
    jog_msg.elbow_pos = elbow_home_pos
    pen_msg.pen_pos = pen_home_pos
    rospy.loginfo("Home positions %s", jog_msg)
    rospy.loginfo("Home position %s", pen_msg)
    jog_servo.publish(jog_msg)
    jog_pen.publish(pen_msg)
    rospy.sleep(DELAY)

# Test for correct message recived
def jog_position(msg: Twist) -> None:
    global shoulder_current_pos
    global elbow_current_pos
    global pen_current_pos

    if msg.angular.z < 0:
        if state == "jog_shoulder": shoulder_current_pos = shoulder_current_pos - jog_size
        if state == "jog_elbow": elbow_current_pos = elbow_current_pos - jog_size
        if state == "jog_pen": pen_current_pos = pen_current_pos - jog_size
        rospy.loginfo("state %s", state) 


    if msg.angular.z > 0:
        if state == "jog_shoulder": shoulder_current_pos = shoulder_current_pos + jog_size
        if state == "jog_elbow": elbow_current_pos = elbow_current_pos + jog_size
        if state == "jog_pen": pen_current_pos = pen_current_pos + jog_size
    
    jog_msg.shoulder_pos = shoulder_current_pos
    jog_msg.elbow_pos = elbow_current_pos
    pen_msg.pen_pos = pen_current_pos

    rospy.loginfo("Current servo positions %s", jog_msg)
    rospy.loginfo("Current pen positions %s", pen_msg)  
    jog_servo.publish(jog_msg)
    jog_pen.publish(pen_msg)
    rospy.sleep(DELAY)

def cmd_parse(msg:String) -> None:
    global state
    rospy.loginfo("parsing command")
    parser = argparse.ArgumentParser (description = "ros brachiograph cli")
    parser.add_argument("cmd")
    parser.add_argument("-j", "--jog", action="store_true")
    parser.add_argument("-s", "--shoulder", action="store_true")
    parser.add_argument("-e", "--elbow", action="store_true")
    parser.add_argument("-p", "--pen", action="store_true")
    

    parser.add_argument("-q", "--square", action="store_true")  
    parser.add_argument("-l", "--line", action="store_true")  

    args = parser.parse_args(shlex.split(msg.data))
    rospy.loginfo(msg.data)  

    if args.cmd == "mode":
        if args.shoulder:
            state = "jog_shoulder"
            rospy.loginfo("joging shoulder")  
        if args.elbow:
            state = "jog_elbow"
            rospy.loginfo("joging elbow")
        if args.pen:
            state = "jog_pen"
            rospy.loginfo("joging pen")
    if args.cmd == "test":
        if args.line:
            state = "line"
            rospy.loginfo("testing line")
    if args.cmd == "home":
            state = "homing"
            rospy.loginfo("homing brachiograph")
            

if __name__ == "__main__":
    rospy.init_node("brachiograph_control_node")
    jog_size = 10

    # setup topics to control into arduino servo angles
    # publishing a integer between pulse width 50 - 400 
    jog_servo = rospy.Publisher("jog_servo", ServoPosition, queue_size=1)
    jog_pen = rospy.Publisher("jog_pen", PenPosition, queue_size=1)
    sub = rospy.Subscriber("/cmd_vel", Twist, jog_position)
    sub = rospy.Subscriber("/cli", String, cmd_parse)

    test_bounds=(-8, 4, 8, 13)
    bg = BrachioGraph(
        # the lengths of the arms
        inner_arm=8,
        outer_arm=8,
        servo_1_centre=225,        # shoulder motor centre pulse-width
        servo_2_centre=225,        # elbow motor centre pulse-width
        # the drawing area
        bounds=test_bounds,
        # angles in degrees and corresponding pulse-widths for the two arm servos
        servo_1_angle_pws=servo_1_angle_pws1,
        servo_2_angle_pws=servo_2_angle_pws2,
        # pulse-widths for pen up/down
        hysteresis_correction_1=20,  # hardware error compensation
        hysteresis_correction_2=20,
        pw_down=260,
        pw_up=375,
    )

    rate = rospy.Rate(10)
    print("Control is Running")
    while not rospy.is_shutdown():
        if state == "line" :
            bg.vertical_lines(test_bounds)
            state = "idle"
        if state == "homing" :
            homing ()
            state = "idle"
        rate.sleep()